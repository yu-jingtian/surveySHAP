boot_twoway[[b]] <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
}
## --- compute 1-way direction table (your definition) ---
calc_oneway_dir <- function(mod, data, vars) {
dir_list <- lapply(vars, function(v) {
emm <- suppressMessages(
emmeans(mod, as.formula(paste("~", v)))
)
df  <- as.data.frame(emm)
names(df)[names(df) == v] <- "level"
prob_df <- get_level_probs(data, v)
df2 <- df %>%
left_join(prob_df, by = "level") %>%
mutate(prob = ifelse(is.na(prob), 0, prob)) %>%
mutate(overall_mean = sum(emmean * prob)) %>%
mutate(direction = emmean - overall_mean) %>%
mutate(variable = v) %>%
select(variable, level, prob, emmean, SE, df, lower.CL, upper.CL,
overall_mean, direction)
df2
})
bind_rows(dir_list)
}
## --- compute 2-way direction table (your definition) ---
calc_twoway_dir <- function(mod, data, vars) {
pairs <- combn(vars, 2, simplify = FALSE)
mu_dotdot <- suppressMessages(
as.data.frame(
emmeans(mod, ~ 1, weights = "proportional")
)$emmean[1]
)
out_list <- lapply(pairs, function(p) {
A <- p[1]; B <- p[2]
emm_ab <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A, " * ", B)),
weights = "proportional")
)
df_ab <- as.data.frame(emm_ab)
names(df_ab)[names(df_ab) == A] <- "level_A"
names(df_ab)[names(df_ab) == B] <- "level_B"
emm_a <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A)),
weights = "proportional")
)
df_a <- as.data.frame(emm_a)
names(df_a)[names(df_a) == A] <- "level_A"
df_a <- df_a %>% select(level_A, mu_a = emmean)
emm_b <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", B)),
weights = "proportional")
)
df_b <- as.data.frame(emm_b)
names(df_b)[names(df_b) == B] <- "level_B"
df_b <- df_b %>% select(level_B, mu_b = emmean)
prob_ab <- as.data.frame(prop.table(table(data[[A]], data[[B]])))
names(prob_ab) <- c("level_A", "level_B", "prob")
df_ab %>%
left_join(df_a, by = "level_A") %>%
left_join(df_b, by = "level_B") %>%
left_join(prob_ab, by = c("level_A", "level_B")) %>%
mutate(prob = ifelse(is.na(prob), 0, prob),
var_A = A,
var_B = B,
mu_dotdot = mu_dotdot,
dir_2way = emmean - mu_a - mu_b + mu_dotdot) %>%
select(var_A, var_B, level_A, level_B, prob,
emmean, SE, df, lower.CL, upper.CL,
mu_a, mu_b, mu_dotdot, dir_2way)
})
bind_rows(out_list)
}
## --- fit on original data ---
mod0 <- lm(form, data = data)
oneway0 <- calc_oneway_dir(mod0, data, vars)
twoway0 <- calc_twoway_dir(mod0, data, vars)
## =========================================================
## Bootstrap
## =========================================================
set.seed(1)
B <- 500  # increase to 1000+ if you want tighter CI
n <- nrow(data)
boot_oneway <- vector("list", B)
boot_twoway <- vector("list", B)
set.seed(1)
B <- 500
n <- nrow(data)
boot_oneway <- vector("list", B)
boot_twoway <- vector("list", B)
for (b in seq_len(B)) {
if (b %% 25 == 0 || b == 1) {
message(sprintf("Bootstrap %d / %d (%.1f%%)",
b, B, 100 * b / B))
}
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) next
boot_oneway[[b]] <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
boot_twoway[[b]] <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
}
View(boot_oneway)
system.time({
boot_oneway[[b]] <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
})
system.time({
boot_twoway[[b]] <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
})
B=5
system.time({
for (b in seq_len(B)) {
if (b %% 25 == 0 || b == 1) {
message(sprintf("Bootstrap %d / %d (%.1f%%)",
b, B, 100 * b / B))
}
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) next
boot_oneway[[b]] <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
boot_twoway[[b]] <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
}
})
library(parallel)
library(dplyr)
B <- 500
n <- nrow(data)
cl <- makeCluster(max(1, detectCores() - 1))
on.exit(stopCluster(cl), add = TRUE)
clusterEvalQ(cl, {
library(dplyr)
library(emmeans)
})
clusterExport(cl, c("data", "n", "B", "vars", "form",
"get_level_probs", "calc_oneway_dir", "calc_twoway_dir"),
envir = environment())
boot_res <- parLapply(cl, seq_len(B), function(b) {
set.seed(100000 + b)  # deterministic per replicate
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
})
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
boot_oneway_df
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
View(boot_res)
library(dplyr)
library(emmeans)
library(future.apply)
## --- choose workers ---
# Windows: use multisession
# Mac/Linux/HPC: you can use multisession too (safe), or multicore if allowed
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 500
n <- nrow(data)
## Make reproducible RNG across workers
# This is important for parallel bootstrap reproducibility
boot_res <- future_lapply(seq_len(B), function(b) {
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
}, future.seed = TRUE)  # <- key line
## Combine results
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
library(future.apply)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 10
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
## Workers need packages loaded
library(dplyr)
library(emmeans)
## Mute the “involvement in interactions” NOTE inside workers too
emm_options(msg.interaction = FALSE)
## Make replicate deterministic (optional but nice)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db),
error = function(e) e)
if (inherits(fit, "error")) {
return(list(b = b, ok = FALSE, stage = "lm",
msg = conditionMessage(fit)))
}
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
dplyr::select(variable, level, direction) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(one, "error")) {
return(list(b = b, ok = FALSE, stage = "oneway",
msg = conditionMessage(one)))
}
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
dplyr::select(var_A, var_B, level_A, level_B, dir_2way) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(two, "error")) {
return(list(b = b, ok = FALSE, stage = "twoway",
msg = conditionMessage(two)))
}
list(b = b, ok = TRUE, one = one, two = two)
}, future.seed = TRUE)
## Summarize failures
fails <- Filter(function(x) isFALSE(x$ok), boot_res)
if (length(fails)) {
print(dplyr::bind_rows(lapply(fails, function(x)
data.frame(b = x$b, stage = x$stage, msg = x$msg, stringsAsFactors = FALSE)
)))
} else {
message("No failures in debug run.")
}
## Extract successful results
ok_res <- Filter(function(x) isTRUE(x$ok), boot_res)
boot_oneway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "one"))
boot_twoway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "two"))
## --- compute 1-way direction table (your definition) ---
calc_oneway_dir <- function(mod, data, vars) {
dir_list <- lapply(vars, function(v) {
emm <- suppressMessages(
emmeans(mod, as.formula(paste("~", v)), data = data)
)
df  <- as.data.frame(emm)
names(df)[names(df) == v] <- "level"
prob_df <- get_level_probs(data, v)
df2 <- df %>%
left_join(prob_df, by = "level") %>%
mutate(prob = ifelse(is.na(prob), 0, prob)) %>%
mutate(overall_mean = sum(emmean * prob)) %>%
mutate(direction = emmean - overall_mean) %>%
mutate(variable = v) %>%
select(variable, level, prob, emmean, SE, df, lower.CL, upper.CL,
overall_mean, direction)
df2
})
bind_rows(dir_list)
}
## --- compute 2-way direction table (your definition) ---
calc_twoway_dir <- function(mod, data, vars) {
pairs <- combn(vars, 2, simplify = FALSE)
mu_dotdot <- suppressMessages(
as.data.frame(
emmeans(mod, ~ 1, weights = "proportional", data = data)
)$emmean[1]
)
out_list <- lapply(pairs, function(p) {
A <- p[1]; B <- p[2]
emm_ab <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A, " * ", B)),
weights = "proportional", data = data)
)
df_ab <- as.data.frame(emm_ab)
names(df_ab)[names(df_ab) == A] <- "level_A"
names(df_ab)[names(df_ab) == B] <- "level_B"
emm_a <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A)),
weights = "proportional", data = data)
)
df_a  <- as.data.frame(emm_a)
names(df_a)[names(df_a) == A] <- "level_A"
df_a <- df_a %>% select(level_A, mu_a = emmean)
emm_b <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", B)),
weights = "proportional", data = data)
)
df_b  <- as.data.frame(emm_b)
names(df_b)[names(df_b) == B] <- "level_B"
df_b <- df_b %>% select(level_B, mu_b = emmean)
prob_ab <- as.data.frame(prop.table(table(data[[A]], data[[B]])))
names(prob_ab) <- c("level_A", "level_B", "prob")
df_ab %>%
left_join(df_a, by = "level_A") %>%
left_join(df_b, by = "level_B") %>%
left_join(prob_ab, by = c("level_A", "level_B")) %>%
mutate(prob = ifelse(is.na(prob), 0, prob),
var_A = A,
var_B = B,
mu_dotdot = mu_dotdot,
dir_2way = emmean - mu_a - mu_b + mu_dotdot) %>%
select(var_A, var_B, level_A, level_B, prob,
emmean, SE, df, lower.CL, upper.CL,
mu_a, mu_b, mu_dotdot, dir_2way)
})
bind_rows(out_list)
}
## --- fit on original data ---
mod0 <- lm(form, data = data)
oneway0 <- calc_oneway_dir(mod0, data, vars)
twoway0 <- calc_twoway_dir(mod0, data, vars)
library(future.apply)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 10
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
## Workers need packages loaded
library(dplyr)
library(emmeans)
## Mute the “involvement in interactions” NOTE inside workers too
emm_options(msg.interaction = FALSE)
## Make replicate deterministic (optional but nice)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db),
error = function(e) e)
if (inherits(fit, "error")) {
return(list(b = b, ok = FALSE, stage = "lm",
msg = conditionMessage(fit)))
}
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
dplyr::select(variable, level, direction) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(one, "error")) {
return(list(b = b, ok = FALSE, stage = "oneway",
msg = conditionMessage(one)))
}
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
dplyr::select(var_A, var_B, level_A, level_B, dir_2way) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(two, "error")) {
return(list(b = b, ok = FALSE, stage = "twoway",
msg = conditionMessage(two)))
}
list(b = b, ok = TRUE, one = one, two = two)
}, future.seed = TRUE)
## Summarize failures
fails <- Filter(function(x) isFALSE(x$ok), boot_res)
if (length(fails)) {
print(dplyr::bind_rows(lapply(fails, function(x)
data.frame(b = x$b, stage = x$stage, msg = x$msg, stringsAsFactors = FALSE)
)))
} else {
message("No failures in debug run.")
}
## Extract successful results
ok_res <- Filter(function(x) isTRUE(x$ok), boot_res)
boot_oneway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "one"))
boot_twoway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "two"))
library(future.apply)
library(dplyr)
library(emmeans)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
emm_options(msg.interaction = FALSE)
set.seed(1)
B <- 500
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
library(dplyr)
library(emmeans)
emm_options(msg.interaction = FALSE)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
}, future.seed = TRUE)
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
summ_twoway <- boot_twoway_df %>%
group_by(var_A, var_B, level_A, level_B) %>%
summarise(
boot_sd = sd(dir_2way, na.rm = TRUE),
ci_lo   = quantile(dir_2way, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(dir_2way, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(dir_2way)),
.groups = "drop"
)
## --- attach to original point estimates ---
oneway_dir_with_ci <- oneway0 %>%
left_join(summ_oneway, by = c("variable", "level")) %>%
rename(
dir_hat = direction,
dir_sd_boot = boot_sd,
dir_ci_lo = ci_lo,
dir_ci_hi = ci_hi
)
twoway_dir_with_ci <- twoway0 %>%
left_join(summ_twoway, by = c("var_A", "var_B", "level_A", "level_B")) %>%
rename(
dir2_hat = dir_2way,
dir2_sd_boot = boot_sd,
dir2_ci_lo = ci_lo,
dir2_ci_hi = ci_hi
)
## Done:
## - oneway_dir_with_ci
## - twoway_dir_with_ci
View(two_way_dir_df)
twoway_dir_with_ci
View(twoway_dir_with_ci)
getwd()
write.csv(oneway_dir_with_ci, "SHAP_rslt/lm_dir_1way_CI.csv", row.names = F)
write.csv(twoway_dir_with_ci, "SHAP_rslt/lm_dir_2way_CI.csv", row.names = F)
