library(emmeans)
})
clusterExport(cl, c("data", "n", "B", "vars", "form",
"get_level_probs", "calc_oneway_dir", "calc_twoway_dir"),
envir = environment())
boot_res <- parLapply(cl, seq_len(B), function(b) {
set.seed(100000 + b)  # deterministic per replicate
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
})
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
boot_oneway_df
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
View(boot_res)
library(dplyr)
library(emmeans)
library(future.apply)
## --- choose workers ---
# Windows: use multisession
# Mac/Linux/HPC: you can use multisession too (safe), or multicore if allowed
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 500
n <- nrow(data)
## Make reproducible RNG across workers
# This is important for parallel bootstrap reproducibility
boot_res <- future_lapply(seq_len(B), function(b) {
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
}, future.seed = TRUE)  # <- key line
## Combine results
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
library(future.apply)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 10
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
## Workers need packages loaded
library(dplyr)
library(emmeans)
## Mute the “involvement in interactions” NOTE inside workers too
emm_options(msg.interaction = FALSE)
## Make replicate deterministic (optional but nice)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db),
error = function(e) e)
if (inherits(fit, "error")) {
return(list(b = b, ok = FALSE, stage = "lm",
msg = conditionMessage(fit)))
}
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
dplyr::select(variable, level, direction) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(one, "error")) {
return(list(b = b, ok = FALSE, stage = "oneway",
msg = conditionMessage(one)))
}
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
dplyr::select(var_A, var_B, level_A, level_B, dir_2way) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(two, "error")) {
return(list(b = b, ok = FALSE, stage = "twoway",
msg = conditionMessage(two)))
}
list(b = b, ok = TRUE, one = one, two = two)
}, future.seed = TRUE)
## Summarize failures
fails <- Filter(function(x) isFALSE(x$ok), boot_res)
if (length(fails)) {
print(dplyr::bind_rows(lapply(fails, function(x)
data.frame(b = x$b, stage = x$stage, msg = x$msg, stringsAsFactors = FALSE)
)))
} else {
message("No failures in debug run.")
}
## Extract successful results
ok_res <- Filter(function(x) isTRUE(x$ok), boot_res)
boot_oneway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "one"))
boot_twoway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "two"))
## --- compute 1-way direction table (your definition) ---
calc_oneway_dir <- function(mod, data, vars) {
dir_list <- lapply(vars, function(v) {
emm <- suppressMessages(
emmeans(mod, as.formula(paste("~", v)), data = data)
)
df  <- as.data.frame(emm)
names(df)[names(df) == v] <- "level"
prob_df <- get_level_probs(data, v)
df2 <- df %>%
left_join(prob_df, by = "level") %>%
mutate(prob = ifelse(is.na(prob), 0, prob)) %>%
mutate(overall_mean = sum(emmean * prob)) %>%
mutate(direction = emmean - overall_mean) %>%
mutate(variable = v) %>%
select(variable, level, prob, emmean, SE, df, lower.CL, upper.CL,
overall_mean, direction)
df2
})
bind_rows(dir_list)
}
## --- compute 2-way direction table (your definition) ---
calc_twoway_dir <- function(mod, data, vars) {
pairs <- combn(vars, 2, simplify = FALSE)
mu_dotdot <- suppressMessages(
as.data.frame(
emmeans(mod, ~ 1, weights = "proportional", data = data)
)$emmean[1]
)
out_list <- lapply(pairs, function(p) {
A <- p[1]; B <- p[2]
emm_ab <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A, " * ", B)),
weights = "proportional", data = data)
)
df_ab <- as.data.frame(emm_ab)
names(df_ab)[names(df_ab) == A] <- "level_A"
names(df_ab)[names(df_ab) == B] <- "level_B"
emm_a <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", A)),
weights = "proportional", data = data)
)
df_a  <- as.data.frame(emm_a)
names(df_a)[names(df_a) == A] <- "level_A"
df_a <- df_a %>% select(level_A, mu_a = emmean)
emm_b <- suppressMessages(
emmeans(mod, as.formula(paste0("~ ", B)),
weights = "proportional", data = data)
)
df_b  <- as.data.frame(emm_b)
names(df_b)[names(df_b) == B] <- "level_B"
df_b <- df_b %>% select(level_B, mu_b = emmean)
prob_ab <- as.data.frame(prop.table(table(data[[A]], data[[B]])))
names(prob_ab) <- c("level_A", "level_B", "prob")
df_ab %>%
left_join(df_a, by = "level_A") %>%
left_join(df_b, by = "level_B") %>%
left_join(prob_ab, by = c("level_A", "level_B")) %>%
mutate(prob = ifelse(is.na(prob), 0, prob),
var_A = A,
var_B = B,
mu_dotdot = mu_dotdot,
dir_2way = emmean - mu_a - mu_b + mu_dotdot) %>%
select(var_A, var_B, level_A, level_B, prob,
emmean, SE, df, lower.CL, upper.CL,
mu_a, mu_b, mu_dotdot, dir_2way)
})
bind_rows(out_list)
}
## --- fit on original data ---
mod0 <- lm(form, data = data)
oneway0 <- calc_oneway_dir(mod0, data, vars)
twoway0 <- calc_twoway_dir(mod0, data, vars)
library(future.apply)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
set.seed(1)
B <- 10
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
## Workers need packages loaded
library(dplyr)
library(emmeans)
## Mute the “involvement in interactions” NOTE inside workers too
emm_options(msg.interaction = FALSE)
## Make replicate deterministic (optional but nice)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db),
error = function(e) e)
if (inherits(fit, "error")) {
return(list(b = b, ok = FALSE, stage = "lm",
msg = conditionMessage(fit)))
}
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
dplyr::select(variable, level, direction) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(one, "error")) {
return(list(b = b, ok = FALSE, stage = "oneway",
msg = conditionMessage(one)))
}
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
dplyr::select(var_A, var_B, level_A, level_B, dir_2way) %>%
dplyr::mutate(b = b),
error = function(e) e
)
if (inherits(two, "error")) {
return(list(b = b, ok = FALSE, stage = "twoway",
msg = conditionMessage(two)))
}
list(b = b, ok = TRUE, one = one, two = two)
}, future.seed = TRUE)
## Summarize failures
fails <- Filter(function(x) isFALSE(x$ok), boot_res)
if (length(fails)) {
print(dplyr::bind_rows(lapply(fails, function(x)
data.frame(b = x$b, stage = x$stage, msg = x$msg, stringsAsFactors = FALSE)
)))
} else {
message("No failures in debug run.")
}
## Extract successful results
ok_res <- Filter(function(x) isTRUE(x$ok), boot_res)
boot_oneway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "one"))
boot_twoway_df <- dplyr::bind_rows(lapply(ok_res, `[[`, "two"))
library(future.apply)
library(dplyr)
library(emmeans)
plan(multisession, workers = max(1, parallel::detectCores() - 1))
emm_options(msg.interaction = FALSE)
set.seed(1)
B <- 500
n <- nrow(data)
boot_res <- future_lapply(seq_len(B), function(b) {
library(dplyr)
library(emmeans)
emm_options(msg.interaction = FALSE)
set.seed(100000 + b)
idx <- sample.int(n, size = n, replace = TRUE)
db  <- data[idx, , drop = FALSE]
fit <- tryCatch(lm(form, data = db), error = function(e) NULL)
if (is.null(fit)) return(list(one = NULL, two = NULL))
one <- tryCatch(
calc_oneway_dir(fit, db, vars) %>%
select(variable, level, direction) %>%
mutate(b = b),
error = function(e) NULL
)
two <- tryCatch(
calc_twoway_dir(fit, db, vars) %>%
select(var_A, var_B, level_A, level_B, dir_2way) %>%
mutate(b = b),
error = function(e) NULL
)
list(one = one, two = two)
}, future.seed = TRUE)
boot_oneway_df <- bind_rows(lapply(boot_res, `[[`, "one"))
boot_twoway_df <- bind_rows(lapply(boot_res, `[[`, "two"))
## --- summarize bootstrap: SD + percentile CI ---
summ_oneway <- boot_oneway_df %>%
group_by(variable, level) %>%
summarise(
boot_sd = sd(direction, na.rm = TRUE),
ci_lo   = quantile(direction, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(direction, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(direction)),
.groups = "drop"
)
summ_twoway <- boot_twoway_df %>%
group_by(var_A, var_B, level_A, level_B) %>%
summarise(
boot_sd = sd(dir_2way, na.rm = TRUE),
ci_lo   = quantile(dir_2way, 0.025, na.rm = TRUE, names = FALSE),
ci_hi   = quantile(dir_2way, 0.975, na.rm = TRUE, names = FALSE),
n_boot  = sum(!is.na(dir_2way)),
.groups = "drop"
)
## --- attach to original point estimates ---
oneway_dir_with_ci <- oneway0 %>%
left_join(summ_oneway, by = c("variable", "level")) %>%
rename(
dir_hat = direction,
dir_sd_boot = boot_sd,
dir_ci_lo = ci_lo,
dir_ci_hi = ci_hi
)
twoway_dir_with_ci <- twoway0 %>%
left_join(summ_twoway, by = c("var_A", "var_B", "level_A", "level_B")) %>%
rename(
dir2_hat = dir_2way,
dir2_sd_boot = boot_sd,
dir2_ci_lo = ci_lo,
dir2_ci_hi = ci_hi
)
## Done:
## - oneway_dir_with_ci
## - twoway_dir_with_ci
View(two_way_dir_df)
twoway_dir_with_ci
View(twoway_dir_with_ci)
getwd()
write.csv(oneway_dir_with_ci, "SHAP_rslt/lm_dir_1way_CI.csv", row.names = F)
write.csv(twoway_dir_with_ci, "SHAP_rslt/lm_dir_2way_CI.csv", row.names = F)
devtools::document()
Error: 'survey_data' is not an exported object from 'namespace:surveySHAP'
devtools::document()
devtools::load_all()
library(surveySHAP)
# Load package functions (adjust if using devtools)
data(survey_data)
str(survey_data)
survey_data <- data_processing(ces22, rural_urban)
nrow(survey_data)
library(dplyr)
library(tidyr)
setwd("E:/OSU/reading/Political Polarization NSF/network_formation/")
data_processing <- function(ces22, rural_urban){
data <- ces22 %>% select(c("gunown","CC22_330a","CC22_330b","CC22_330c",
"CC22_330d","CC22_330e","CC22_330f",
"pid3", "countyfips", "race", "gender4", "educ",
"commonweight"))
# columns (1 = support, 2 = oppose)
gun_vars     <- c("CC22_330a","CC22_330b","CC22_330c",
"CC22_330d","CC22_330e","CC22_330f")
# items where "support" means looser control -> reverse
reverse_vars <- c("CC22_330a","CC22_330c","CC22_330f")
# 1) pull to a numeric matrix
M <- as.matrix(ces22[, gun_vars])
# 2) recode to 1 = stricter, 0 = looser, else NA (vectorized)
M[] <- ifelse(M == 1, 1, ifelse(M == 2, 0, NA_real_))
# 3) reverse the specified columns (still vectorized)
rev_idx <- match(reverse_vars, gun_vars)
M[, rev_idx] <- 1 - M[, rev_idx]
# 4) fast row-level stats
n_ans   <- rowSums(!is.na(M))
gun_sum <- rowSums(M, na.rm = TRUE)           # counts stricter responses (0–6)
# --- Option B: normalize by observed range (your proposal) ---
rng <- range(gun_sum, na.rm = TRUE)
den <- diff(rng)
gun_score <- if (den > 0) (gun_sum - rng[1]) / den else rep(NA_real_, length(gun_sum))
data$gun_control <- gun_score
data$countyfips <- as.numeric(data$countyfips)
data <- data %>%
mutate(
gun_own = factor(
gunown,
levels = c(1, 2, 3, 8),
labels = c("Own a gun",
"HH owns (not self)",
"No guns in HH",
"Not sure")
)
)
data <- data %>%
mutate(
partisan = factor(
pid3,
levels = c(1, 2, 3),
labels = c("Dem.", "Rep.", "Ind.")
),
race = factor(
race,
levels = c(1, 2, 3, 4),
labels = c("White", "Black", "Hipanic", "Asian")
),
gender = factor(
ifelse(gender4 == 1, "Man",
ifelse(gender4 == 2, "Woman",
ifelse(gender4 %in% c(3,4), "Other", NA))),
levels = c("Man", "Woman", "Other")
),
educ = as.numeric(educ),
weight = as.numeric(commonweight)
)
data <- inner_join(data, rural_urban, by="countyfips")
data <- data %>% select(c("gun_control", "gun_own", "partisan", "race",
"gender", "educ", "rucc", "weight"))
return(na.omit(data))
}
ces22 <- read_dta("CCES22_Common_OUTPUT_vv_topost.dta")
library(dplyr)
library(tidyr)
library(haven)
setwd("E:/OSU/reading/Political Polarization NSF/network_formation/")
data_processing <- function(ces22, rural_urban){
data <- ces22 %>% select(c("gunown","CC22_330a","CC22_330b","CC22_330c",
"CC22_330d","CC22_330e","CC22_330f",
"pid3", "countyfips", "race", "gender4", "educ",
"commonweight"))
# columns (1 = support, 2 = oppose)
gun_vars     <- c("CC22_330a","CC22_330b","CC22_330c",
"CC22_330d","CC22_330e","CC22_330f")
# items where "support" means looser control -> reverse
reverse_vars <- c("CC22_330a","CC22_330c","CC22_330f")
# 1) pull to a numeric matrix
M <- as.matrix(ces22[, gun_vars])
# 2) recode to 1 = stricter, 0 = looser, else NA (vectorized)
M[] <- ifelse(M == 1, 1, ifelse(M == 2, 0, NA_real_))
# 3) reverse the specified columns (still vectorized)
rev_idx <- match(reverse_vars, gun_vars)
M[, rev_idx] <- 1 - M[, rev_idx]
# 4) fast row-level stats
n_ans   <- rowSums(!is.na(M))
gun_sum <- rowSums(M, na.rm = TRUE)           # counts stricter responses (0–6)
# --- Option B: normalize by observed range (your proposal) ---
rng <- range(gun_sum, na.rm = TRUE)
den <- diff(rng)
gun_score <- if (den > 0) (gun_sum - rng[1]) / den else rep(NA_real_, length(gun_sum))
data$gun_control <- gun_score
data$countyfips <- as.numeric(data$countyfips)
data <- data %>%
mutate(
gun_own = factor(
gunown,
levels = c(1, 2, 3, 8),
labels = c("Own a gun",
"HH owns (not self)",
"No guns in HH",
"Not sure")
)
)
data <- data %>%
mutate(
partisan = factor(
pid3,
levels = c(1, 2, 3),
labels = c("Dem.", "Rep.", "Ind.")
),
race = factor(
race,
levels = c(1, 2, 3, 4),
labels = c("White", "Black", "Hipanic", "Asian")
),
gender = factor(
ifelse(gender4 == 1, "Man",
ifelse(gender4 == 2, "Woman",
ifelse(gender4 %in% c(3,4), "Other", NA))),
levels = c("Man", "Woman", "Other")
),
educ = as.numeric(educ),
weight = as.numeric(commonweight)
)
data <- inner_join(data, rural_urban, by="countyfips")
data <- data %>% select(c("gun_control", "gun_own", "partisan", "race",
"gender", "educ", "rucc", "weight"))
return(na.omit(data))
}
ces22 <- read_dta("CCES22_Common_OUTPUT_vv_topost.dta")
rural_urban <- read.csv("Ruralurbancontinuumcodes2023.csv") %>%
select("FIPS", "RUCC_2023")
colnames(rural_urban) <- c("countyfips", "rucc")
#############################
##
## one/two-way strength
##
#############################
survey_data <- data_processing(ces22, rural_urban)
nrow(survey_data)
# assume data is your dataframe
save(survey_data, file = "survey_data.rda", compress = "xz")
devtools::document()
devtools::document()
devtools::load_all()
library(surveySHAP)
# Load package functions (adjust if using devtools)
data(survey_data)
str(survey_data)
?survey_data
